% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Introduzione ai casi d'uso per l'analisi comparativa}
\label{casi-uso}
%**************************************************************

\intro{Il capitolo descrive in dettaglio il prototipo realizzato e la sua migrazione da REST a GraphQL. A seguire si illustrerà una ulteriore migrazione realizzata sull'applicativo aziendale SushiLab.}\\
%\subsection{Confronto con stakeholder}
\section{Prototipo}
\subsection{Introduzione}
Il prototipo è stato realizzato avendo presente i seguenti obbiettivi:
\begin{itemize}
  \item familiarizzare con le tecnologie Spring e Angular per la realizzazione rispettivamente di backend e frontend;
  \item familiarizzare con la realizzazione delle API sia con lo stile architetturale REST che con il linguaggio di query GraphQL;
  \item avere un caso d'uso ulteriore a conferma delle analisi che verranno poi ricavate dalla migrazione dell'applicativo SushiLab;
\end{itemize}
Si è scelto di realizzare un gestionale server - client in grado di gestire un insieme di impiegati. Ogni impiegato può lavorare in un dipartimento e può dividere il suo tempo su uno o più progetti. Una sede aziendale può contenere uno o più dipartimenti.
\subsection{Architettura ed entità}
\subsubsection*{Architettura generale dell'applicativo}
L'applicativo segue l' architettura raffigurata nell'immagine \ref{prototype-architecture}. Il backend del prototipo è stato realizzato con framework Spring Boot mentre il frontend con framework Angular.
\FloatBarrier
\begin{figure}[!h]
\centering
\includegraphics[width=1\linewidth]{immagini/prototypeArchitecture.pdf}
\caption{Architettura del prototipo}
\label{prototype-architecture}
\end{figure}
\FloatBarrier
Le richieste effettuate dai servizi del client vengono mappate sul REST controller del server il quale, dopo la rielaborazione interna delle richiesta, ritorna la risposta al client; quest'ultimo può dunque aggiornare la vista visualizzata dall'utente. In seguito vengono affrontati più nel dettaglio i moduli interni sia per quanto riguarda il server che il client.
\subsubsection*{Entità e relazioni}
\label{entity-relation}
Trattandosi di un gestionale aziendale semplificato si prevedono solo quattro entità principali:
\begin{itemize}
  \item \textbf{Employee}: l'impiegato che può lavorare ad uno o più progetti e in un dipartimento;
  \item \textbf{Project}: un progetto aziendale a cui partecipano più impiegati;
  \item \textbf{Site}: la sede aziendale, può avere più dipartimenti;
  \item \textbf{Department}: un dipartimento che appartiene ad una sede.
\end{itemize}
Ciascuna entità è caratterizzata dai campi presenti in figura \ref{ER-prototype}. I campi in grassetto rappresentano la chiave primaria, quelli sottolineati le chiavi esterne. Le relazioni presenti tra le varie entità sono:
\begin{itemize}
  \item \textbf{many to many}: è presente tra Employee e Project, infatti ciascun impiegato può lavorare a più progetti e ciascun progetto può avere più impiegati; viene scomposta in due relazioni \textit{one-to-many} con la tabella \textit{Employees\_Projects};
  \item \textbf{one to many}: è presente in due situazioni:
  \begin{itemize}
    \item tra Employee e Department, infatti ciascun impiegato deve lavorare almeno in un dipartimento, mentre ciascun dipartimento può ospitare più impiegati;
    \item tra Department e Site, ciascun dipartimento può appartenere esclusivamente ad una sede, mentre ciascuna sede può esser composta da più dipartimenti.
  \end{itemize}
\end{itemize}
%%% IMG
\FloatBarrier
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{immagini/ER_prototype.pdf}
\caption{Schema ER delle entità}
\label{ER-prototype}
\end{figure}
\FloatBarrier
%%% IMG
\subsection{Progettazione e realizzazione backend}
\subsubsection*{Architettura backend}
È stato deciso di seguire il pattern \textbf{controller - service - repository} per la realizzazione del server del prototipo.  Il pattern rispetta perfettamente il principio di "Separation Of Concerns". Di seguito in figura \ref{controller-service-repository} è possibile visualizzare l'architettura del backend.
%%%% IMG
\FloatBarrier
\begin{figure}[!h]
\centering
\includegraphics[width=0.8\linewidth]{immagini/controllerServiceRepository.pdf}
\caption{Architettura interna backend}
\label{controller-service-repository}
\end{figure}
\FloatBarrier
%%%% IMG
Nell'immagine \ref{sequence-diagram} è possibile visualizzare il diagramma di sequenza di una richiesta GET al server da parte del client. La richiesta in questo caso è andata a buon fine ritornando al client i dati richiesti.
\FloatBarrier
\begin{figure}[!h]
\centering
\includegraphics[width=1\linewidth]{immagini/getRequestFromClient.pdf}
\caption{Diagramma di sequenza di una richiesta GET elaborata dal server}
\label{sequence-diagram}
\end{figure}
\FloatBarrier
Il pattern prevedere la gestione delle entità e delle chiamate alle API attraverso tre strati:
\begin{itemize}
  \item \textbf{Controller layer}: è l'unico responsabile della comunicazione con i client, inoltre gestisce le interfacce REST e invoca lo strato di servizio;
  \item \textbf{Service layer}: è lo strato tra controller e repository, si occupa della business logic e qualora sia necessario visualizzare, salvare, modificare o eliminare dati allora comunica con lo strato di persistenza;
  \item \textbf{Repository layer}: si tratta dello strato inferiore dell'architettura, si occupa della gestione dei dati e delle loro modifiche nonché della gestione del database.
\end{itemize}
Durante la realizzazione viene seguito il percorso inverso rispetto a quanto visto nell'immagine \ref{controller-service-repository}: la realizzazione avviene partendo dallo strato di persistenza, dunque dalla creazione delle entità e del livello di repository.
\subsubsection*{Entità e repository}
A ciascuna entità del database viene fatta corrispondere una classe in Java quindi sono state realizzate quattro classi rappresentanti le entità Employee, Project, Department e Site.\\
Ciascuna classe implementa la classe \textit{Serializable}, così facendo è possibile serializzare i dati in flussi di byte. La serializzazione viene utilizzata poiché si tratta di dati che dovranno essere memorizzati nel database, è necessario serializzarli poiché abbandonano la Java Virtual Machine. Viene inoltre utilizzato un \textit{serialVersionUID} per attribuire una versione a ciascuna classe serializzabile in modo da garantire la consistenza delle classi memorizzate in banca dati.\\
Di seguito l'esempio dell'implementazione della classe Employee:
%%% IMG
\begin{lstlisting}[language=Java, title={Employee.java}, morecomment={[s][\color{DarkOrchid}]{\@}{\ }}, morecomment={[s][\color{OliveGreen}]{"}{"}},]
@Entity
@Table (name = "EMPLOYEE")
@Data
@NoArgsConstructor ()
@AllArgsConstructor ()
public class Employee implements Serializable {
    private static final long serialVersionUID = 8452515756703751450L;
    @Id
    @Column (name = "ID")
    private String id;
    private String name;
    private String surname;
    private Long salary;
    private Date birth;
    @ManyToMany
    @JoinTable (name = "EMPLOYEE_PROJECTS", joinColumns = { @JoinColumn (name = "EMPLOYEE_ID")},
            inverseJoinColumns = { @JoinColumn (name = "PROJECT_ID")})
    @JsonIgnore
    private Set<Project> projects = new HashSet<>();
    @ManyToOne
    @JsonBackReference(value = "employee_department")
    private Department department;
}
\end{lstlisting}
%\FloatBarrier
%\begin{figure}[!ht]
%\centering
%\includegraphics[width=0.9\linewidth]{immagini/employee_entity.png}
%\caption{Esempio di implementazione dell'entità Employee in Spring Boot.}
%\label{employee-entity-definition}
%\end{figure}
%\FloatBarrier
%%% IMG
Vengono attribuite alla classe Employee diverse annotazioni Spring, tra queste:
\begin{itemize}
  \item \textbf{@Entity}: si tratta dell'annotazione che permette di mappare la classe Employee come tabella nel database. Questa annotazione è resa disponibile dal modulo Spring Data JPA il quale implementa la specifica delle Java Persistence API attraverso Hibernate ORM e permette dunque il mapping della classi con corrispettive entità nel database;
  \item \textbf{@Table}: questa annotazione permette di specificare il nome della tabella generata o presente nel database durante la sua creazione o aggiornamento;
  \item \textbf{@Data}: grazie alla libreria \textit{lombok} è possibile, attribuendo alla classe questa annotazione, generare automaticamente tutti i metodi get e set per ciascun campo della classe;
  \item \textbf{@NoArgConstructor e @AllArgConstructor}: permettono di generare tutte le combinazioni di costruttori con e senza parametri.
\end{itemize}
Le annotazioni applicate agli attributi della classe sono:
\begin{itemize}
  \item \textbf{@Id}: associato al campo \textit{id}, specifica durante il mapping che si tratta della chiave primaria;
  \item \textbf{@GeneratedValue}: associato al campo \textit{id}, specifica che quando una nuova istanza dell'entità viene creata, deve essere generato un nuovo id randomico;
  \item \textbf{@ManyToMany} e \textbf{@ManyToOne}: queste specificano il tipo di relazione che è presente con le altre entità, sono rispettivamente associate ai campi \textit{projects}, con il quale Employee ha una relazione molti a molti e infine al campo \textit{department}, con il quale Employee ha una relazione molti a uno;
  \item \textbf{@JoinTable}: è associata al campo \textit{projects}, e poiché le relazioni molti a molti necessitano di una ulteriore tabella per la memorizzazione di tutte le associazioni, questa annotazione permette di specificarne il nome, ovvero \textit{EMPLOYEE\_PROJECTS} e i nomi delle due colonne, ovvero \textit{EMPLOYEE-ID} e \textit{PROJECT-ID};
  \item \textbf{@JsonIgnore}: associato al campo \textit{projects}, permette di escluderlo dalla serializzazione;
  \item \textbf{@JsonBackReference}: associato al campo \textit{department}, permette di dare una direzionalità alla relazione molti a uno con Department, fondamentale per evitare il problema della ricorsione infinita.
\end{itemize}
Analogamente sono state realizzate le classi corrispondenti alle entità Project, Department e Site.\\\\
A questo punto si procede con la realizzazione delle classi repository: ciascuna entità ha una propria repository corrispondente. Viene estesa l'interfaccia \textbf{JPArepository<T, ID>} con T il tipo della entità che si vuole gestire, mentre ID è il tipo della chiave primaria dell'entità T. La repository JPA estende le seguenti interfacce:
\begin{itemize}
  \item \textbf{CrudRepository<T, ID>}: contiene i metodi per gestire le classiche operazioni CRUD;
  \item \textbf{PagingAndSortingRepository<T, ID>}: contiene i metodi per gestire la paginazione e l'ordinamento;
\end{itemize}
Estendendo la JPARepository per ciascun tipo è possibile avere a disposizione diversi metodi per eseguire operazioni già implementate come: findAll, count, existById, SaveAndFlush, ecc...\\
Per realizzare ulteriori metodi è sufficiente rispettare le corretta sintassi del nome del metodo affinché Spring si occupi in automatico della sua implementazione.\\
Nel caso in cui si voglia realizzare una query personalizzata si utilizza l'annotazione \textbf{@Query} alla quale è possibile passare come attributo la query che desideriamo in linguaggio JPQL. Di seguito un esempio di quanto appena detto:
\begin{lstlisting}[language=Java, title={EmployeeRepository.java}, morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@Repository ()
public interface EmployeeRepository extends JpaRepository<Employee, String> {
    List<Employee> findByName(String name);
    List<Employee> findBySurname(String surname);
    List<Employee> findByDepartment_id(Long id);
    @Query ("SELECT DISTINCT e FROM Employee e WHERE e.birth BETWEEN ?1 AND ?2")
    List<Employee> findByBornDateRange(@Param ("from") Date from, @Param ("to") Date to);
}
\end{lstlisting}
%%% IMG
%\FloatBarrier
%\begin{figure}[!ht]
%\centering
%\includegraphics[width=1\linewidth]{immagini/employee_repository.png}
%\caption{Esempio di implementazione della repository di Employee in Spring Boot.}
%\label{employee-repository}
%\end{figure}
%\FloatBarrier
%%% IMG
Oltre ai classici metodi di ricerca disponibili sono stati realizzati alcuni metodi per la ricerca di impiegati per nome, per cognome e per id di dipartimento in cui lavorano. Infine è stata realizzata una query personalizzata per la ricerca di impiegati nati in un range di date.\\
Da evidenziare l'uso dell'annotazione \textbf{@Repository} attribuita alla'interfaccia, fondamentale al fine di indicare che la classe fornisce meccanismi per modellare i dati del database.
\subsubsection*{Service}
Il compito dello strato di servizio è facilitare la comunicazione tra controller e repository oltre a realizzare la business logic dell'applicativo.\\
Per ciascun repository, dunque per ciascuna entità, è stato realizzato un servizio specifico per gestirne le logiche.\\
Al fine di rispettare i principi SOLID della programmazione, per questioni di loose coupling, IoC e semplicità nel testing, è stato scelto di implementare il pattern secondo il quale per ogni entità viene realizzata una interfaccia del corrispondente servizio e sua relativa implementazione. In figura \ref{service-serviceImpl} relativo all'entità Employee.
%%% IMG
\FloatBarrier
\begin{figure}[!ht]
\centering
\includegraphics[width=0.4\linewidth]{immagini/service_serviceImpl.pdf}
\caption{Esempio di implementazione dell'interfaccia EmployeeService}
\label{service-serviceImpl}
\end{figure}
\FloatBarrier
%%% IMG
A seguire viene riportato l'esempio dell'implementazione del servizio \textbf{EmployeeServiceImpl}:
\begin{lstlisting}[language=Java, title={EmployeeServiceImpl.java}, morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@Service ()
public class EmployeeServiceImpl implements EmployeeService{
    @Autowired
    private EmployeeRepository employeeRepository;
    @Override
    public List<Employee> SelAll() { ... }
    @Override
    public Optional<Employee> SelById(String id){ ... }
    @Override
    public List<Employee> SelByName(String name){ ... }
    @Override
    public List<Employee> SelBySurname(String surname){ ... }
    @Override
    public List<Employee> SelByDepartment(Long id){ ... }
    @Override
    public List<Employee> SelByBornInRange(Date from, Date to){ ... }
    @Override
    public void InsEmployee(Employee employee){ ... }
    @Override
    public void DelEmployee(Employee employee){ ... }
}
\end{lstlisting}
%%% IMG
%\FloatBarrier
%\begin{figure}[!ht]
%\begin{mdframed}
%\centering
%\includegraphics[width=1\linewidth]{immagini/employeeServiceImpl.png}
%\end{mdframed}
%\caption{Classe EmployeeServiceImpl.}
%\label{employeeServiceImpl}
%\end{figure}
%\FloatBarrier
%%% IMG
In figura \ref{employeeServiceImpl} è possibile notare come la classe sia caratterizzata dall'annotazione \textbf{@Service} la quale viene utilizzata per indicare classi che contengono la business logic e per marcare la classe come service provider.\\\\
Le annotazioni utilizzate sono:
\begin{itemize}
  \item \textbf{@Autowired}: attribuita al campo \textit{employeeRepository} produce la dependency injection della repository \textit{EmployeeRepository} nel servizio;
  \item \textbf{@Override}: utilizzata da tutti i metodi, avverte che i metodi dichiarati nell'interfaccia vengono implementati;
\end{itemize}
Sono stati resi disponibili metodi semplici che vanno ad invocare, grazie alla dipendenza con la repository, le query già disponibili con la \textit{JPARepository<T, ID>} e la query vista precedenemente \textit{SelByBornInRage}.\\
Lo strato di servizio si incarica della gestione delle eccezioni estendendo il gestore  \textit{HandlerExceptionResolver}; in questo modo si migliora il comportamento di default che non sempre fornisce informazioni comprensibili sulla natura dell'errore.
\subsubsection*{Controller}
Lo strato di controller si occupa di gestire le richieste che il server riceve attraverso il protocollo HTTP e di mapparle inoltre sui metodi corrispondenti. Di seguito il codice del controller:
\begin{lstlisting}[title={EmployeeController.java}, language=Java, morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@RestController
@RequestMapping (value = "api/employee")
public class EmployeeController {

    @Autowired ()
    private EmployeeService employeeService;

    @CrossOrigin
    @GetMapping (value = "/all", produces = "application/json")
    public ResponseEntity<List<Employee>> listAllEmployee(){ ... }

    @GetMapping (value = "name/{name}", produces = "application/json")
    public ResponseEntity<List<Employee>> listEmployeeByName(@PathVariable("name") String name){ ... }

    @GetMapping(value = "surname/{surname}", produces = "application/json")
    public ResponseEntity<List<Employee>> listEmployeeBySurname(@PathVariable("surname") String surname){ ... }

    @GetMapping (value = "department/{department_id}", produces = "application/json")
    public ResponseEntity<List<Employee>> listEmployeeByDepartment(@PathVariable("department_id") Long id){ ... }

    @GetMapping (value = "born/{from}/{to}", produces = "application/json")
    public ResponseEntity<List<Employee>> listEmployeeBornInDateRange(@PathVariable("from")
            @DateTimeFormat (pattern="yyyy-MM-dd") Date from, @PathVariable ("to") @DateTimeFormat  (pattern="yyyy-MM-dd") Date to){ ... }

    @PostMapping (value = "/insert", consumes = "application/json")
    public ResponseEntity<Employee> createEmployee(@RequestBody Employee employee){ ... }

    @DeleteMapping(value = "/delete/{id}")
    public ResponseEntity<?> deleteEmployee(@PathVariable ("id") String id){ ... }

    @PutMapping (value = "/update/{id}", consumes = "application/json")
    public ResponseEntity<?> updateEmployee(@PathVariable("id") String id, @RequestBody Employee employee){ ... }
}
\end{lstlisting}
%\FloatBarrier
%\begin{figure}[!ht]
%\begin{mdframed}
%\centering
%\includegraphics[width=1\linewidth]{immagini/EmployeeController.png}
%\end{mdframed}
%\caption{Classe EmployeeController.}
%\label{employeeController}
%\end{figure}
%\FloatBarrier
Questa classe permette di gestire e mappare le richieste a seconda dell'url dal quale proviene la richiesta. Di seguito le annotazioni associate alla classe:
\begin{itemize}
  \item \textbf{@RestController}: definisce la classe come controller di tipo REST;
  \item \textbf{@RequestMapping}: indica l'url al quale il client dovrà mandare le richieste per quello specifico controller.
\end{itemize}
Il controller ha una dipendenza con il servizio \textit{EmployeeService}, necessaria per l'invocazione dei suoi metodi. Ciascun metodo ritorna l'oggetto \textit{ResponseEntity<>} e consiste in una risposta HTTP alla quale viene modificato l'header e aggiunto il JSON nel body prima di essere ritornato. Le annotazioni associate ai metodi del controller sono:
\begin{itemize}
  \item \textbf{@GetMapping}: indica che si tratta di un metodo per la risoluzione di una richiesta GET; specifica l'url al quale ricevere la richiesta e ciò che viene ritornato, ovvero un file JSON;
  \item \textbf{@PostMapping}: indica che si tratta di un metodo per la risoluzione di una richiesta POST, specifica l'url al quale ricevere la richiesta e ciò che richiede in input, ovvero un file JSON passato attraverso il body della richiesta HTTP;
  \item  \textbf{@DeleteMapping}: indica che si tratta di un metodo per la risoluzione di una richiesta DELETE, specifica l'url al quale ricevere la richiesta;
  \item \textbf{@PutMapping}: indica che si tratta di un metodo per la risoluzione di una richieste PUT, specifica l'url al quale ricevere la richiesta e ciò che richiede in input, ovvero un file JSON passato attraverso il body della richiesta HTTP;
\end{itemize}
Oltre alle annotazioni sopra riportate sono presenti tra gli argomenti le annotazioni \textbf{@PathVariable} per indicare che si tratta di una variabile che verrà fornita nell'url nel posto definito dal nome specificato, \textbf{@RequestBody} ovvero un argomento che verrà fornito nel body della chiamata HTTP e infine \textbf{@DateTimeFormat} per specificare il formato del tipo di dato \textit{Date} che verrà passato dal client nell'url della richiesta.\\
Si rendono disponibili i seguenti metodi:
\begin{itemize}
  \item \textbf{listAllEmployee}: ritorna tutti gli impiegati presenti;
  \item \textbf{listEmployeeByName}: ritorna tutti gli impiegati con una determinato nome;
  \item \textbf{listEmployeeBySurname}: ritorna tutti gli impiegati con un determinato cognome;
  \item \textbf{listEmployeeByDepartment}: ritorna tutti gli impiegati di un dipartimento;
  \item \textbf{listEmployeeByBornInDataRange}: ritorna tutti gli impiegati nati in un determinato range di date;
  \item \textbf{updateEmployee}: consente l'aggiornamento dei campi dati di un impiegato;
  \item \textbf{createEmployee}: aggiunge un nuovo impiegato;
  \item \textbf{deleteEmployee}: rimuove un impiegato.
\end{itemize}
\subsubsection*{Testing API}
Essendo un prototipo incentrato sulla realizzazione delle API sono stati svolti in maniera semplice e veloce i test per gli strati di servizio e repository, essi non verranno riportati. Per quanto riguarda i test sui controller sono stati svolti test più approfonditi.\\
Per eseguire i test sui metodi del controller è stato scelto di utilizzare il framework JUnit5.\\
Il primo test realizzato è uno \textit{Smoke Test} che si incarica di verificare che il contesto Spring abbia effettivamente creato i controller dell'applicazione. In figura \ref{smoke-test} la classe \textit{SmokeTest} con una dipendenza per ciascun controller risolta con la dependency injection grazie all'annotazione \textbf{@Autowired}. Per ciascun controller è presente il relativo metodo di verifica, ciascuno annotato con \textbf{@Test} per indicare a JUnit5 che si tratta di un metodo di test.\\
Come possiamo notare è presente l'annotazione \textbf{@SpringBootTest}, necessaria per indicare a Spring Boot dove si trova la principale classe di configurazione e dunque avviare il contesto Spring. Da notare inoltre che ciascun metodo è dichiarato in maniera da poter sollevare eccezioni se necessario.
\begin{lstlisting}[language=Java, title={SmokeTest.java}, morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@SpringBootTest (classes = PrototypeManagerApplication.class)
public class SmokeTest {
    @Autowired
    private EmployeeController employeeController;
    @Autowired
    private ProjectController projectController;
    @Autowired
    private DepartmentController departmentController;
    @Autowired
    private SiteController siteController;
    @Test
    public void contextLoadsEmployee() throws Exception {
        assertThat(employeeController).isNotNull();
    }
    @Test
    public void contextLoadsDepartment() throws Exception {
        assertThat(departmentController).isNotNull();
    }
    @Test
    public void contextLoadsProject() throws Exception {
        assertThat(projectController).isNotNull();
    }
    @Test
    public void contextLoadsSite() throws Exception {
        assertThat(siteController).isNotNull();
    }
}
\end{lstlisting}
%\FloatBarrier
%\begin{figure}[!ht]
%\begin{mdframed}
%\centering
%\includegraphics[width=0.7\linewidth]{immagini/SmokeTest.png}
%\end{mdframed}
%\caption{Classe \textit{SmokeTest} sulla creazione dei controller.}
%\label{smoke-test}
%\end{figure}
%\FloatBarrier
Passiamo ora ai test sui metodi del controller \textit{EmployeeController}. Di seguito è raffigurata la classe \textit{EmployeeControllerTest}, sono stati riportati solo i primi due metodi di test per questioni di spazio.
\begin{lstlisting}[language=Java, title={EmployeeControllerTest.java}, morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@WebMvcTest (EmployeeController.class)
public class EmployeeControllerTest {
    @Autowired ()
    private MockMvc mockMvc;
    @Autowired ()
    private ObjectMapper objectMapper;
    @MockBean ()
    private EmployeeService employeeService;
    //Testing listAllEmployee()
    @Test ()
    void listAllEmployeeWihtNotEmptyList() throws Exception{
        int a = 0;
        int b = 0;
        int c = a+b;
    }
    @Test ()
    void listAllEmployeeWihtEmptyList() throws Exception{
        int a = 0;
        int b = 0;
        int c = a+b;
    }
}
\end{lstlisting}
La classe \textit{EmployeeControllerTest} utilizza l'annotazione \textbf{@WebMvcTest} per caricare nel contesto di test esclusivamente il controller testato.\\
Nella classe di test \textit{EmployeeControllerTest} sono dichiarate tre dipendenze fondamentali risolte con la dependency injection:
\begin{itemize}
  \item \textbf{MockMvc}: ogetto utilizzato per la simulazione di chiamate HTTP e la verifica della risposta;
  \item \textbf{ObjectMapper}: oggetto utilizzato nei test per la serializzazione e deserializzazione degli oggetti JSON in oggetti java e viceversa;
  \item \textbf{EmployeeService}: servizio che viene utilizzato nei test che usa l'annotazione \textbf{@MockBean} per aggiungere un mock dell'oggetto \textit{EmployeeService}.
\end{itemize}
Infine si riporta di seguito l'implementazione dettagliata del metodo di test \textit{createEmployee} seguendo il pattern \textit{Arrange - Act - Assert}.
\begin{lstlisting}[language=Java, title={createEmployee()}, morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@Test ()
void createEmployee() throws Exception{
    //Arrange
    Employee employee = new Employee();
    employee.setName("Mario");
    employee.setSurname("Rossi");
    LocalDate date = LocalDate.of(1992, 05, 03);
    employee.setBirth(Date.from(date.atStartOfDay(ZoneId.systemDefault()).toInstant()));
    //Act & Assert
    mockMvc.perform(post("/api/employee/insert").contentType(MediaType.APPLICATION_JSON)
            .contentType(objectMapper.writeValueAsString(employee))).andExpect(status().isCreated())
            .andDo(print());
}
\end{lstlisting}
Nella prima parte (arrange) viene creato un nuovo Employee e gli viene assegnato un nome, un cognome e una data di nascita; successivamente (act) si esegue la chiamata GET utilizzando l'oggetto \textit{MockMvc} e passando nel body della richiesta HTTP l'oggetto Java Employee trasformato in JSON grazie all'\textit{ObjectMapper}. Per ultima la fase finale (assert) in cui si verifica che lo stato di ritorno sia \textit{created}, in caso contrario il test fallisce.
\subsection{Progettazione e realizzazione frontend}
Per quanto riguarda il frontend dell'applicativo è stato utilizzato il framework Angular per realizzare una Single-Page Application. Si tratta di un frontend minimale, realizzato con il solo scopo di comprendere e sviluppare la parte di comunicazione con il server utilizzando al massimo le REST API disponibili. Per questo motivo non è stata effettuata alcuna considerazione sull'utenza e sono stati tralascati completamente aspetti quali estetica grafica, accessibilità e responsive design.\\
\subsubsection*{Architettura}
Angular segue un'architettura ben precisa, in figura \ref{angular-architecture} è possibile visualizzarne la struttura:
\FloatBarrier
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{immagini/angularArchitecture.pdf}
\caption{Architettura della Web Application del prototipo.}
\label{angular-architecture}
\end{figure}
\FloatBarrier
Si tratta di una piattaforma modulare che basa la sua struttura sulla divisione in moduli. Ciascun modulo è composto da una componente ed un template detto anche vista; questi comunicano tra loro attraverso i metadati: l'utente che interagisce con la vista può attivare l'inizio di un procedura sulla componente. La componente spesso per l'esecuzione di alcune procedure invoca in suo aiuto i servizi iniettati nella componente stessa. \\\\
Nel corso della tesi quando si tratta il frontend verranno principalmente considerati i servizi; infatti quest'ultimi si incaricano della comunicazione con il server attraverso le API.
\subsubsection*{Funzionalità}
Di seguito si approfondisce la parte riguardante l'entità Employee, le altre entità sono state trattate in maniera analoga.\\
In linea con le query rese disponibili dal backend, devono essere presenti le seguenti funzionalità:
\begin{itemize}
  \item \textbf{Visualizzazione degli Employee}: devono poter essere visualizzata la lista degli impiegati permettendo la ricerca per: nome, cognome, data di nascita o dipartimento di appartenenza;
  \item \textbf{Aggiunta di un Employee}: deve essere possibile aggiungere un nuovo impiegato potendone specificare: nome, cognome, salario, data di nascita, dipartimento di appartenenza e infine i progetti che segue;
  \item \textbf{Aggiornamento di un Employee}: deve essere possibile aggiornare i campi dati di un impiegato specificandone l'id e il/gli campo/i da modificare;
  \item \textbf{Eliminazione di un Employee}: deve essere possibile eliminare un impiegato specificandone l'id.
\end{itemize}
Nel sezione sucessiva verrà mostrato come sono state implementate le funzionalità appena introdotte.
\subsubsection*{Realizzazione}
Inizialmente sono state create le interfacce per poter creare gli oggetti corrispondenti alle quattro entità del prototipo. A seguire l'esempio della dichiarazione della interfaccia dell'entità Employee:
\begin{lstlisting}[language=JavaScript, title={object.ts}]
export interface Employee {
  id: string;
  name: string;
  surname : string;
  salary: number;
  birth: Date;
  department: Department;
  project: [Project];
}
\end{lstlisting}
%\FloatBarrier
%\begin{figure}[!ht]
%\centering
%\includegraphics[width=0.3\linewidth]{immagini/employeeInterface.png}
%\caption{Interfaccia di Employee.}
%\label{employee-interface}
%\end{figure}
%\FloatBarrier
A seguire è stata implementata l'interaccia grafica inserendo nella pagina iniziale la possibilità di effettuare due scelte: la prima scelta riguarda l'entità, mentre la seconda riguarda l'operazione che si vuole eseguire sull'entità selezionata. In figura \ref{first-page} è possibile visualizzare le scelte:
\FloatBarrier
\begin{figure}[!ht]
\centering
\includegraphics[width=0.7\linewidth]{immagini/firstPage.png}
\caption{Prima pagina della Web Application.}
\label{first-page}
\end{figure}
\FloatBarrier
Una volta selezionate le due opzioni viene aggiunta dinamicamente la possibilità di specificare i dettagli della richiesta. Vengono di seguito mostrate le diverse interfacce che variano al variare della scelta selezionata e il servizio che permette di eseguire la chiamata alle API del backend.\\
In figura \ref{get-employee} abbiamo il caso in cui è stata selezionata l'entità Employee con operazione GET:
\FloatBarrier
\begin{figure}[!ht]
\centering
\includegraphics[width=0.7\linewidth]{immagini/getEmployee.png}
\caption{Opzioni disponibili con operazione GET selezionata.}
\label{get-employee}
\end{figure}
\FloatBarrier
Viene dunque esposta una lista contenente tutti gli impiegati, per ciascun impiegato vengono mostrati id, nome e cognome, salario e data di nascita. Successivamente viene visualizzata la scelta riguardante il campo per il quale eseguire la ricerca, in questo caso è stato scelto il nome, dunque inserendo nell'apposito campo di input il nome e selezionendo il bottone è possibile effettuare la ricerca per nome.\\
La scelta dell'opzione GET permette alla vista di invocare immediatamente il servizio che esegue una chiamata alle REST API del backend per ricevere la lista di tutti gli employee, stessa cosa accade anche quando premiamo il bottone "Esegui ricerca " dopo aver inserito il nome. Il servizio in questione si chiama \textit{EmployeeService} e di seguito ne è riportata l'implementazione:
\begin{lstlisting}[language=JavaScript, title={employee.service.ts}]
export class EmployeeService {

  url: String = 'http://localhost:8080/api/employee/';

  constructor(private http: HttpClient) { }

  allEmployees(){
    return this.http.get(this.url + "all")
    }
  employeeByName(name: String){ ... }
  employeeBySurname(surname: String){ ... }
  employeeByDepartment(id: String){ ... }
  employeeByBornInDateRange(from: Date, to: Date){ ... }
  createOrUpdateEmployee(employee: Employee){ ... }
  deleteEmployee(id: String){ ... }
}
\end{lstlisting}
%\FloatBarrier
%\begin{figure}[!ht]
%\centering
%\includegraphics[width=0.6\linewidth]{immagini/employeeService.png}
%\caption{Classe \textit{EmployeeService}.}
%\label{employee-service}
%\end{figure}
%\FloatBarrier
Il servizio realizzato per le chiamate alle REST API del backend permette di essere invocato direttamente dalla componenta relativa alla vista sulla quale è stata eseguita la selezione di un elemento HTML da parte dell'utente. È inoltre presente una dipendenza con l'oggetto \textit{HttpClient}, il quale viene iniettato nel servizio venendo passato come parametro al costruttore; la sua funzionalità è quella di permettere l'esecuzione delle chiamate alle API sul backend.\\\\
Proseguendo vengono visualizzati ora i casi in cui si sceglie come operazione quella di modificare o aggiungere un nuovo impiegato. In figura \ref{post-employee} è possibile visualizzare la porzione di interfaccia grafica per l'inserimento o l'aggiornamento di un impiegato:
\FloatBarrier
\begin{figure}[!ht]
\centering
\includegraphics[width=0.3\linewidth]{immagini/postEmployee.png}
\caption{Opzioni disponibili con operazione INSERT/UPDATE selezionata}
\label{post-employee}
\end{figure}
\FloatBarrier
Una volta inseriti tutti i valori per ciascun campo, tranne il campo ID che viene generato automaticamente, è possibile aggiungere un nuovo impiegato. Qualora invece si specificasse anche l'id, allora si tratterebbe di una modifica di un impiegato già esistente, questo solo se l'id inserito corrisponde veramente all'id di un employee. Anche in questo caso selezionando il bottone "Insert or update Employee!" viene invocato il metodo del servizio riportato in figura \ref{employee-service}.\\
Per finire in figura \ref{delete-employee} il caso in cui venga selezionata l'opzione DELETE:
\FloatBarrier
\begin{figure}[!ht]
\centering
\includegraphics[width=0.3\linewidth]{immagini/deleteEmployee.png}
\caption{Opzioni disponibili con operazione DELETE selezionata}
\label{delete-employee}
\end{figure}
\FloatBarrier
\subsubsection*{Testing}
I test di unità sono stati implementati seguendo il pattern \textit{Arrange - Act - Assert} sui metodi del servizio riportato in figura \ref{employee-service}. Di seguito è possibile visualizzare la funzione \textit{describe} la quale viene utilizzata per raggruppare un insieme di test:
\begin{lstlisting}[language=JavaScript, title={employee.service.spec.test}]
describe('EmployeeService', () => {
  let service: EmployeeService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [EmployeeService],
    });
    service = TestBed.inject(EmployeeService);
    httpMock = TestBed.inject(HttpTestingController);
  });
  afterEach(() => {
    httpMock.verify();
  });
  it('should retrieve all employees'), () => { ... }
  it('should retrive all employees by name'), () => { ... }
  it('should retrive all employees by surname'), () => { ... }
  it('should retrive all employees by department'), () => { ... }
  it('should create one employee'), () => { ... }
  it('should update one employee'), () => { ... }
  it('should delete one employee'), () => { ... }
\end{lstlisting}
Viene incluso il modulo Angular \textit{HttpClientTestModule}, necessario al fine di importare il servizio iniettabile \textit{HttpTestingController} utilizzato per il mocking e il flushing e dunque per eliminare le microtask in sospeso. Sono inoltre presenti le funzioni \textit{BeforeEach} utilizzata per configurare l'ambiente di test, dunque importare i moduli necessari e risolvere le dipendenze e la funzione \textit{afterEach} utilizzata per controllare, dopo l'esecuzion di ciascun test, che non siano rimaste richieste in sospeso. Infine, con la funzione \textit{it} viene definito un titolo per ciascun test e implementato il test stesso.\\
Più nello specifico si può visualizzare l'implementazione di un test per il metodo \textit{allEmployee} del servizio \textit{EmployeeService}:
\begin{lstlisting}[language=JavaScript, title={employee.service.spec.test}]
it('should retrieve all employees'), () => {
  //Arrange
  const employeesList: Employee[] = [
    {id: "F3BASD", name: "Mario", surname: "Rossi", salary: 1500, birth: new Date("05/04/1999")},
    {id: "AIF07S", name: "Giulio", surname: "Gialli", salary: 1500, birth: new Date("02/01/1988")},
    {id: "LOSF2D", name: "Serafino", surname: "Bianchi", salary: 1500, birth: new Date("22/11/1979")},
    {id: "PIFA2A", name: "Marta", surname: "Verdi", salary: 1500, birth: new Date("30/01/1995")},
  ];
  //Act & Assert
  service.allEmployees().subscribe(employees => {
    expect(employees).toBe(employeesList);
  })

  const request = httpMock.expectOne(`${service.url}/all`);
  request.flush(employeesList);
  expect(request.request.method).toBe('GET');

}
\end{lstlisting}
%\FloatBarrier
%\begin{figure}[!ht]
%\centering
%\includegraphics[width=0.8\linewidth]{immagini/allEmployeeTest.png}
%\caption{Test sul metodo \textit{allEmployee()} di \textit{EmployeeService}.}
%\label{get-all-test}
%\end{figure}
%\FloatBarrier
Viene inizialmente creato un array di Employee che ci si aspetterà di ricevere dalla chiamata e sucessivamente si verifica il risultato atteso tramite la funzione \textit{expect}.Per finire si controlla che l'url sia corretto, che venga effettuata una sola chiamata GET e che si tratti effettivamente di una richiesta GET.
\subsection{Migrazione da REST a GraphQL}
In questa sezione si affronta la migrazione sia del backend che del frontend da REST API a GraphQL API.
\subsubsection*{Migrazione Backend}
Il backend realizzato in Spring Boot con l'aiuto del modulo Spring Data REST per la realizzazione dei controller di REST API deve essere riscritto in parte utilizzando il modulo Spring GraphQL per la realizzazione dei controller in GraphQL.\\
É stata adottata la tecnica \textit{Schema First} che prevede la costruzione del GraphQL Schema ed, a seguire, l'implementazione dei resolver delle API. Nonostante i resolver fossero già realizzati per il prototipo in REST è comunque necessario adattarli all'utilizzo di questo nuovo protocollo.\\
Le quattro entità presenti, ovvero Employee, Project, Department e Site devono essere riportate tutte nel GraphQL schema poiché sono tutte accessibili dal client; esse saranno definite sia come entità di input che di output poiché GraphQL differenzia i due tipi nelle query, mutation e subscription. Di seguito è possibile visualizzare l'implementazione dei tipi \textit{Employee} e \textit{EmployeeInput}.
\begin{lstlisting}[language=GraphQL, title={schema.graphqls}]
type Employee {
  id: ID
  name: String
  surname: String
  salary: Int
  birth: Date
  projects: [Project]
  department: Department
}
\end{lstlisting}
\begin{lstlisting}[language=GraphQL, title={schema.graphqls}]
type EmployeeInput {
  id: ID
  name: String
  surname: String
  salary: Int
  birth: Date
  projectsId: [ID]
  departmentId: ID
}
\end{lstlisting}
Come si può notare i due tipi \textit{Employee} e \textit{EmployeeInput} non corrispondono completamente: i campi \textit{projects} e \textit{department} di \textit{Employee} non sono presenti in \textit{EmployeeInput}, o  meglio sono presenti ma in diversa forma. Il motivo di tale differenza si può sintetizzare in questo modo:
\begin{itemize}
  \item il tipo \textit{Employee} verrà ritornato al client su richiesta; dovrà contenere le varie istanze dei progetti a cui un impiegato sta partecipando come pure l'oggetto dipartimento;
  \item il tipo \textit{EmployeeInput} indica come fornire i dati necessari all'aggiunta/aggiornamento dell'impiegato; è sufficiente dunque passare gli id dei progetti coinvolti come pure l'id del dipartimento dell'impiegato.
\end{itemize}
A questo punto è possibile definire le query, le mutation ed eventualmente le subscription che si vogliono rendere disponibili al client. Di seguito è possibile visualizzare la dichiarazione delle query, mutation e della subscription riguardanti l'entità Employee.
\begin{lstlisting}[language=GraphQL, title={schema.graphqls}]
type Query {
  allEmployees: [Employee]
  employeeByName(name: String!): [Employee]
  employeeBySurname(surname: String!): [Employee]
  employeeByDepartment(id: ID!): [Employee]
  employeeBornInDateRange(from: Date!, to: Date!): [Employee]
}
type Mutation {
  addEmployee(employee: EmployeeInput!): Employee
  updateEmployee(employee: EmployeeInput!): Employee
  delEmployee(id: ID!): Employee
}
type Subscription {
  newEmployeeAdded():[Employee]
}
\end{lstlisting}
Il dato ritornato è di tipo \textit{Employee} per tutte le operazioni mentre quello di input è \textit{EmployeeInput}.\\
È stata aggiunta inoltre una subscription per sfruttare a pieno le funzionalità di GraphQL. Questa subscription permette al client di ricevere i nuovi impiegati aggiunti senza per forza richiederli.
\paragraph{Migrazione dei controller}
La migrazione non coinvolge gli strati di servizio e repository in quanto non è necessario apportare modifiche alle logiche e alla gestione del database. L'unico strato da riscrivere parzialmente è lo strato del controller.\\
Come prima cosa si realizzano le classi Java corrispondenti ai tipi di input; questo è necessario poiché nei metodi del controller è previsto come parametro di input la versione di input dell'impiegato.\\
L'implementazione del controller risulta differente rispetto a quella vista con le REST API. Di seguito è possibile visualizzarne la struttura ed i metodi:
\begin{lstlisting}[language=Java, title={EmployeeController.java}, morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@Controller
public class EmployeeController {
    @Autowired
    private final EmployeeService employeeService;

    @QueryMapping
    Object employeeByName(@Argument String name) { ... }
    @QueryMapping
    Object employeeBySurname(@Argument String surname) { ... }
    @QueryMapping
    Object employeeByDepartment(@Argument String id) { ... }
    @QueryMapping
    Object employeeBornInDateRange(@Argument Date from, @Argument Date to) { ... }
    @MutationMapping
    Object addEmployee (@Argument EmployeeInput employee) { ... }
    @MutationMapping
    Object updateEmployee (@Argument EmployeeInput employee) { ... }
    @MutationMapping
    Object delEmployee(@Argument String id) { ... }
    @SubscriptionMapping
    Publisher<List<Employee>> newEmployeeAdded() { ... }
}
\end{lstlisting}
Come si può notare si tratta di un controller simile a quello REST nei metodi, tuttavia le annotazioni e alcune implementazioni differiscono. Vengono utilizzate le annotazioni:
\begin{itemize}
  \item \textbf{@Controller}: indica che si tratta di un generico controller (non più REST controller);
  \item \textbf{@QueryMapping}: attribuito ai metodi che risolvono le query;
  \item \textbf{@MutationMapping}: attribuito ai metodi che risolvono le mutation;
  \item \textbf{@SubscriptioMapping}: attribuito al metodo che risolve la subscription;
  \item \textbf{@Argument}: utilizzato per specificare gli argomenti.
\end{itemize}
Queste annotazioni sono fondamentali poiché permettono di effettuare il mapping tra i tipi, le query, le mutation e le subscription definiti nel GraphQL Schema e quelli definiti nel controller. Per questo motivo il nome di ciascun metodo o tipo negli argomenti deve corrispondere esattamente al nome nel GraphQL Schema, altrimenti il mapping non andrà a buon fine e verranno generati degli errori.\\
L'implementazione dei metodi del controller risulta simile a quella dei corrispettivi metodi nel REST controller. Tuttavia, trattandosi di una particolare funzionalità disponibile esclusivamente in GraphQL; viene riportata l'implementazione della subscription \begin{lstlisting}[language=Java, title={newEmployeeAdded()} morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@SubscriptioMapping ()
Publisher<List<Employee>> newEmployeeAdded(){
  return subscriber -> Executors.newScheduledThreadPool(1).scheduleAtFixedRate(() -> {
    List<Employee> employees = employeeService.SelAll();
    subscriber.onNext(employees);
    }, 0, 2, TimeUnit.SECONDS);
}
\end{lstlisting}
L'implementazione della subscription permette al subscriber, in questo caso il client, di ricevere la lista aggiornata al verificarsi di un evento. L'oggetto \textit{Publisher<>} permette di inviare la lista aggiornata a tutti i subscribers in tempo reale, così facendo il client non dovrà richiedere periodicamente la lista con la query \textit{allEmployee}.
\paragraph{Strutture delle risposte HTTP in GraphQL e gestione degli errori}
Le risposte che il server GraphQL ritorna al client in seguito ad una query, mutation o subscription sono dei file JSON. Questi JSON possono contenere tre tipi di campi:
\begin{itemize}
  \item \textbf{Data}: ritornato nella risposta solo in caso di successo, assume valore \textit{null} al presentarsi di un errore;
  \item \textbf{Errors}: ritornato solo ed esclusivamente al verificarsi di uno o più errori, contiene le informazioni necessarie all'interpretazione dell'anomalia;
  \item \textbf{Extensions}: campo facoltativo a disposizione degli sviluppatori di backend, può essere utilizzato ad esempio per ritornare il timestamp dell'esecuzione della query.
\end{itemize}
Analizzando gli errori che si possono verificare durante l'esecuzione di una query, mutation o subscription nel server GraphQL, si individuano tre categorie:
\begin{itemize}
  \item \textbf{Errori di sintassi}: si tratta di errori nella sintassi della query. Se la query è sintatticamente scorretta l'errore sarà di tipo "Syntax Error"; in questo caso l'esecuzione della query non parte nemmeno;
  \item \textbf{Errori di validazione}: si verificano quando vengono specificati nella richiesta tipi non coerenti con lo schema. In questo caso l'errore si verifica durante l'esecuzione, dunque viene ritornato sia il campo \textit{data}, con valore null o con i dati parziali che il server è riuscito a recuperare, che il campo \textit{errors} che indica la presenza di uno o più errori di data fetching;
  \item \textbf{Errori nei resolver:} si verificano durante la risoluzione della query e non sono legati al fatto che la query sia formulata male o con tipi sbagliati. Questi errori devono essere gestiti lato server;
\end{itemize}
Quando si verificano errori di sintassi o validazione la risposta l'errore ritornato indica perfettamente la natura dell'errore. La terza tipologia di errore quasi sempre risulta incomprensibile dal client. Questo accade perché la gestione delle eccezioni durante l'esecuzione di una richiesta è presa in carico dall'interfaccia predefinita \textit{DataFetcherExceptionHandler} la quale permette la dichiarazione di più risolutori di eccezioni detti \textit{DataFetcherExceptionResolver}. Questi ultimi vengono invocati sequenzialmente fino a quando uno di essi è in grado di risolvere l'eccezione; in caso contrario viene ritornata una informazione di errore incomprensibile con categoria \textit{"INTERNAL\_ERROR"}. Questo per uno sviluppatore può essere un problema poiché non è facile individuare la provenienza dell'errore. Per questo motivo sono stati creati differenti resolvers per le varie eccezioni che possono verificarsi. Di seguito l'esempio di implementazione di un resolver che riscrive il metodo di risoluzione delle eccezioni \textit{resolveToSingleError} al fine di risolvere l'eccezione \textit{EmployeeNotFound}.
\begin{lstlisting}[language=Java, title={GraphQLExceptionResolver.java}, morecomment={[s][\color{DarkOrchid}]{@}{\ }},  morecomment={[s][\color{OliveGreen}]{"}{"}},]
@Component ()
public class GraphQLExceptionResolver extends DataFetcherExceptionResolverAdapter {
  @Override
  protected GraphQLError resolveToSingleError(Throwable ex, DataFetchingEnvironment env) {
    if(ex instanceof EmployeeNotFound) {
      return GraphQLErrorBuilder.newError()
                .errorType(ErrorType.NOT_FOUND)
                .message(ex.getMessage())
                .path(env.getExecutionStepInfo().getPath())
                .location(env.getField().getSourceLocation())
                .build();
    } else {
      return null;
    }
  }
}
\end{lstlisting}
Com'è possibile notare viene ritornato un oggetto di tipo \textit{GraphQLError} con i campi impostati correttamente. Al presentarsi dell'eccezione il client sarà ora in grado di comprendere il motivo di errore.
\subsubsection*{Migrazione Frontend}
La migrazione del frontend richiede uno sforzo minore rispetto al backend, infatti è sufficiente effettuare la migrazione esclusivamente dei servizi che si occupano dell'invocazione delle API.\\
Il servizio visualizzato precedentemente in figura \ref{employee-service} \textit{EmployeeService} non cambia la sua struttura; i metodi rimangono gli stessi, tuttavia l'implementazione del metodo deve cambiare. Oltre all'implementazione dei metodi cambia anche l'oggetto che permette il fetching dei dati dal server, infatti trattandosi ora di un GraphQL Server, sarà necessaria la dipendenza dall'oggetto \textit{Apollo} utilizzato nel fetching dei dati da un server GraphQL.\\
Si riporta l'implementazione del metodo  \textit{allEmployees}.
\begin{lstlisting}[language=JavaScript, title={allEmployees()}]
  allEmployees(){
      return this.apollo.watchQuery<any>({
        query: gql`
        {
          allEmployees {
            id
            name
            surname
            birth
            salary
          }
        }`,
        }).valueChanges;
      }
\end{lstlisting}
Attraverso il metodo \textit{watchQuery<>} dell'oggetto \textit{apollo} è possibile eseguire la query all'endopoint del server GraphQL. Il metodo ritorna un oggetto di tipo \textit{Observable} ed il subscriber dovrà occuparsi di gestire quanto ritornato dal servizio. Nel caso in cui la query sia andata a buon fine dovrà leggere le informazioni presenti nel campo \textit{"data"}; nel caso contrario dovrà occuparsi di mostrare il messaggio ed il tipo dell'errore presente nel campo \textit{"errors"}.
\section{SushiLab}
\label{sushi-lab}
\subsection{Confronto con stakeholder}
Circa dopo un mese dall'inizio dello stage è stato realizzato un confronto con gli stakeholder. Con il tutor interno dell'azienda SyncLab, ovvero Fabio Pallaro sono stati valutati alcuni applicativi già implementati che seguissero l'architettura server - client per effettuarne la migrazione da REST API a GraphQL API.\\
Tra tutti l'applicativo selezionato è stato \textbf{SushiLab}, il quale è stato realizzato da alcuni stagisti nei mesi precedenti. Il motivo che ci ha portato a concordare questa scelta è stato principalmente il fatto che fosse un applicativo con una struttura API articolata.
\subsection{Comprensione dell'applicativo e obbiettivi}
SushiLab è un applicativo che mira ad automatizzare il processo di tracciamento degli ordini nei ristoranti di sushi all you can eat. Si tratta di un applicativo composto da:
\begin{itemize}
  \item \textbf{Backend}: realizzato in Java con il framework Spring Boot con database PostgreSQL;
  \item \textbf{Frontend}: realizzato in Typescript con il framework Angular;
  \item \textbf{Componente di Machine Learning}: consente il riconoscimento dei piatti tramite la fotocamera del telefono;
  \item \textbf{Applicativo mobile}: la versione mobile della Web App.
\end{itemize}
Il mio intervento sulla Web Application prevede di lavorare sulla comunicazione tra backend e frontend, effettuando una migrazione completa delle REST API sviluppate trasformandole in GraphQL API, esattamente come è stato fatto per il prototipo.\\\\
Di seguito verranno analizzate le strutture del backend e del frontend tralasciando gli aspetti implementativi specifici già illustrati nel prototipo e concentrandosi principalmente sulla parte di comunicazione tramite API.
\subsection{Panoramica del backend}
Il backend sviluppato in Java con il framework Spring Boot segue l'architettura proposta per il prototipo, ovvero il pattern repository - service - controller. Di seguito verranno analizzate e descritte brevemente le componenti principali degli strati di persistenza e di business logic, si approfondirà maggiormente lo strato di controller.
\subsubsection{Entità}
In figura \ref{ER-sushilab} è possibile visualizzare lo schema ER delle entità presenti e le relazioni che intercorrono. Vengono tralasciati i campi per non entrare eccessivamente nel dettaglio.
\FloatBarrier
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{immagini/ER_sushilab.pdf}
\caption{Diagramma ER delle entità}
\label{ER-sushilab}
\end{figure}
\FloatBarrier
Sono dunque presenti le entità:
\begin{itemize}
  \item \textbf{PiattoUpload}: un tipo di piatto con allergeni e ingredienti;
  \item \textbf{PiattoPreview}: l'anteprima di un piatto associata ad un \textit{PiattoUpload};
  \item \textbf{SezionePreview}: un insieme di piatti di una particolare categoria;
  \item \textbf{Menù}: un insieme di sezioni di piatti, si tratta del menù di un ristorante;
  \item \textbf{Utente}: l'utente registrato, può anche essere un gestore e dunque essere il proprietario del ristorante e dunque poter apportare delle modifiche ai menù, ai piatti;
  \item \textbf{FasciaOraria}: una fascia oraria in cui può essere disponibile un Menù;
  \item \textbf{InformazioniPiatto}: le caratteristiche di un singolo utente riguardo ingredienti che non può mangiare, se gli è piaciuto un piatto specifico o se ha preferenze per particolari tipi di menù;
  \item \textbf{Blacklist}: l'insieme di ingredienti che un cliente preferisce non mangiare;
  \item \textbf{IdToken}: un token identificativo associato ad un utente dopo il login;
  \item \textbf{Session}: la situazione di un singolo tavolo in un determinato momento con determinati clienti, quando un cliente si siede ad un tavolo può aprire una sessione e invitare gli amici allo stesso tavolo;
  \item \textbf{Ordine}: gli ordini effettuati in una specifica sessione o da una specifica persona;
  \item \textbf{Allergeni}: le sostanze che tipicamente possono causare allergie;
  \item \textbf{Ingredienti}: i possibili ingredienti nei vari piatti.
\end{itemize}
Ciascuna di queste entità ha la corrispettiva classe Java nel backend. Per ciascuna entità è stata realizzata la corrispettiva repository estendendo l'interfaccia \textit{JPARepository<T, ID>} per la gestione dei dati e delle risorse nel database.
\subsubsection*{Servizi}
Lo strato di servizio presente prevede la definizione di solo due classi per la gestione delle logiche del backend. Di seguito vengono elencate le funzioni dei due servizi.
\paragraph{ClientService}
Il primo servizio gestisce le logiche delle possibili richieste del client. Questo servizio permette la gestione di:
\begin{itemize}
  \item \textbf{Utenti}: permette tutte le operazioni di login, registrazione di un nuovo utente, aggiunta dell'IdToken ad un utente all'apertura di una nuova sessione ad un tavolo e infine il recupero e modifica della password;
  \item \textbf{Preferenze Utente}: permette di modificare le preferenze di un utente e modificare, aggiungere o eliminare le valutazioni attribuite ai piatti; inoltre consente di visualizzare gli ingredienti nella blacklist di uno specifico utente;
  \item \textbf{Sessioni}: permette di creare ed eliminare le sessioni;
  \item \textbf{Ordini}: permette la gestione degli ordini da parte di un utente, di aggiungerne di nuovi o di visualizzarli;
  \item \textbf{Gestore}: permette di verificare che un utente corrisponda o meno al gestore;
  \item \textbf{Menu}: permette di visualizzare il menù di un ristorante.
\end{itemize}
\paragraph{GestoreService}
Il servizio \textit{GestoreService} gestisce le logiche riguardanti le operazioni realizzabili da un utente gestore, dunque permette:
\begin{itemize}
  \item \textbf{Piatti}: la gestione dei piatti, è possibile visualizzarli, eliminarli, modificarli e aggiungerne di nuovi;
  \item \textbf{Menu}: la gestione del menù, è possibile riorganizzarlo diversamente e attribuirgli differenti fasce orarie di disponibilità.
\end{itemize}
\subsubsection*{Controller}
Infine abbiamo lo strato più importante per gli scopi della tesi. Si tratta dello strato di controller il quale prevede cinque controller principali, di seguito verranno analizzati tutti i metodi di ciascun controller tralasciandone gli aspetti implementativi.
\paragraph{LoginController}
Il seguente controller dichiara una dipendenza con il servizio \textit{ClientService}. Di seguito la tabella dei metodi:
%//////////////////////// INIZIO TABELLA ////////////////////////
%//////////////////////// INIZIO TABELLA ////////////////////////
\begin{table}[!h]
\renewcommand{\arraystretch}{1.1}
\centering
\begin{tabular}{|c|c|c|l|}
\hline
\rowcolor[HTML]{C0C0C0}
{\color[HTML]{000000} \textbf{Metodo}} & {\color[HTML]{000000} \textbf{Parametri}} & {\color[HTML]{000000} \textbf{Descrizione}}                                           & {\color[HTML]{000000} \textbf{Azione}} \\ \hline
\textbf{eseguiLogin}                   & Utente utente             & \begin{tabular}[c]{@{}c@{}}Controlla ed effettua\\ il login di un utente\end{tabular} & POST                           \\ \hline
\end{tabular}
\caption{Metodi del controller \textit{LoginController}}
\end{table}
%//////////////////////// FINE TABELLA ////////////////////////
%//////////////////////// FINE TABELLA ////////////////////////
\paragraph{UtenteController}
Questo controller dichiara una dipendenza con il servizio \textit{ClientService} ed è composto dai metodi specificati nella seguente tabella:
%//////////////////////// INIZIO TABELLA ////////////////////////
%//////////////////////// INIZIO TABELLA ////////////////////////
\begin{table}[!h]
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor[HTML]{C0C0C0}
{\color[HTML]{000000} \textbf{Metodo}}        & {\color[HTML]{000000} \textbf{Parametri}}                                                                              & {\color[HTML]{000000} \textbf{Descrizione}}                                                                                                                & {\color[HTML]{000000} \textbf{Azione}} \\ \hline
{\color[HTML]{000000} \textbf{ottieniUtente}}          & {\color[HTML]{000000} String idPersona}                                                                                & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ricerca un utente\\ per id\end{tabular}}                                                                  & {\color[HTML]{000000} GET}             \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{registraUtente}}         & {\color[HTML]{000000} Utente utente}                                                                                   & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Aggiunge un nuovo\\ utente\end{tabular}}                                                                  & {\color[HTML]{000000} POST}            \\ \hline
{\color[HTML]{000000} \textbf{modificaStatoPreferiti}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPersona\\ String idPiatto \\ String Param\end{tabular}}                   & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Modifica i preferiti\\ di un utente,  con dei \\  nuovi piatti\end{tabular}}                                 & {\color[HTML]{000000} POST}            \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{modificaValutazione}}    & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPersona\\ String idPiatto\\ String param\end{tabular}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Modifica la \\ valutazione di una \\ persona rispetto ad \\ un piatto con nuovi\\ parametri\end{tabular}} & {\color[HTML]{000000} POST}            \\ \hline
{\color[HTML]{000000} \textbf{recuperoPassword}}       & {\color[HTML]{000000} String param}                                                                                    & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Invia un codice alla \\ mail del cliente per il\\ recupero password\end{tabular}}               & {\color[HTML]{000000} POST}            \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{verificaCodice}}         & {\color[HTML]{000000} String param}                                                                                    & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Verifica il codice\\ di recupero password\end{tabular}}                                                   & {\color[HTML]{000000} POST}            \\ \hline
{\color[HTML]{000000} \textbf{reimpostaPassword}}      & {\color[HTML]{000000} String param}                                                                                    & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Imposta una nuova \\ password per un utente\end{tabular}}                                                 & {\color[HTML]{000000} POST}            \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{aggiornaBlacklist}}      & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPersona\\ Ingredienti ingredienti\end{tabular}}           & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Aggiorna la blacklist \\ di una persona con i \\ nuovi ingredienti\end{tabular}}                          & {\color[HTML]{000000} POST}            \\ \hline
{\color[HTML]{000000} \textbf{ottieniBlacklist}}       & {\color[HTML]{000000} String idPersona}                                                                                & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna la lista di \\ ingredienti nella \\ blacklist di un utente\end{tabular}}                          & {\color[HTML]{000000} GET}             \\ \hline
\end{tabular}
\caption{Metodi del controller \textit{UtenteController}}
\end{table}
%//////////////////////// FINE TABELLA ////////////////////////
%//////////////////////// FINE TABELLA ////////////////////////
\paragraph{TavoloController}
Anche il seguente controller dichiara una dipendenza con \textit{ClientService} ed i suoi metodi gestiscono gli utenti, gli ordini ed i tavoli.
% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[!h]
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor[HTML]{C0C0C0}
{\color[HTML]{000000} \textbf{Metodo}}                   & {\color[HTML]{000000} \textbf{Parametri}}                                                            & {\color[HTML]{000000} \textbf{Descrizione}}                                                                                                    & {\color[HTML]{000000} \textbf{Azione}} \\ \hline
{\color[HTML]{000000} \textbf{creaSessione}}             & {\color[HTML]{000000} String idPersona}                                                              & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Permette la \\ creazione di una sessione\\  da parte di una persona\end{tabular}}             & {\color[HTML]{000000} POST}            \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{ottieniSessione}}          & {\color[HTML]{000000} String idTavolo}                                                               & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna la sessione \\ attiva in un determinato\\ tavolo\end{tabular}}                        & {\color[HTML]{000000} GET}             \\ \hline
{\color[HTML]{000000} \textbf{chiudiSessione}}           & {\color[HTML]{000000} String idTavolo}                                                               & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Chiude la sessione in un\\ determinato tavolo\end{tabular}}                                   & {\color[HTML]{000000} DELETE}          \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{ottieniOrdiniPersona}}     & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idTavolo\\ String idPersona\end{tabular}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna gli ordini di \\ una persona in uno\\ specifico tavolo\end{tabular}}                  & {\color[HTML]{000000} GET}             \\ \hline
{\color[HTML]{000000} \textbf{modificaOrdiniPersona}}    & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idTavolo\\ String idPersona \\ ListaOrdini ordini\end{tabular}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Modifica gli ordini di \\ una persona in uno \\ specifico tavolo\end{tabular}}                & {\color[HTML]{000000} POST}            \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{ottieniOrdiniTavolo}}      & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idTavolo\\ String idPersona\end{tabular}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna tutti gli ordini\\ effettuati dalle persone \\ di un determinato tavolo\end{tabular}} & {\color[HTML]{000000} GET}             \\ \hline
{\color[HTML]{000000} \textbf{ottieniGliOrdiniInArrivo}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idTavolo\\ String idPersona\end{tabular}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna gli ordini che\\ sono quasi pronti per \\ essere consegnati\end{tabular}}             & {\color[HTML]{000000} GET}             \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{spostaGliOrdiniInArrivo}}  & {\color[HTML]{000000} String idTavolo}                                                               & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Imposta come "in arrivo"\\ gli ordini di un \\ determinato tavolo\end{tabular}}                 & {\color[HTML]{000000} POST}            \\ \hline
\end{tabular}
\caption{Metodi del controller \textit{TavoloController}}
\end{table}
%//////////////////////// FINE TABELLA ////////////////////////
%//////////////////////// FINE TABELLA ////////////////////////
%//////////////////////// INIZIO TABELLA ////////////////////////
%//////////////////////// INIZIO TABELLA ////////////////////////
\paragraph{MenuController}
Il \textit{MenuController} richiede la dipendenza con il servizio \textit{ClientService}. Ha i seguenti metodi:
\begin{table}[!h]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor[HTML]{C0C0C0}
{\color[HTML]{000000} \textbf{Metodo}}                   & {\color[HTML]{000000} \textbf{Parametri}}                                                            & {\color[HTML]{000000} \textbf{Descrizione}}                                                                                                    & {\color[HTML]{000000} \textbf{Azione}} \\ \hline
{\color[HTML]{000000} \textbf{ottieniMenu}}              & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}int idMenu\\ String idPersona\end{tabular}}         & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna il menu \\ ricercato per id\end{tabular}}                                             & {\color[HTML]{000000} GET}             \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{ottieniListaFasce}}        & {\color[HTML]{000000} int idMenu}                                                                    & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna le fasce orarie\\ di un certo menu\end{tabular}}                                      & {\color[HTML]{000000} GET}             \\ \hline
{\color[HTML]{000000} \textbf{ottieniListaPreferiti}}    & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}int idMenu\\ String idPersona\end{tabular}}         & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna la lista dei\\ piatti preferiti di una \\ persona\end{tabular}}                       & {\color[HTML]{000000} GET}             \\ \hline
\end{tabular}
\caption{Metodi del controller \textit{MenuController}}
\end{table}
%//////////////////////// FINE TABELLA ////////////////////////
%//////////////////////// FINE TABELLA ////////////////////////
\paragraph{GestoreController}
Infine è presente il \textit{GestoreController} con dipendenza dal servizio \textit{GestoreService}. I metodi che lo caratterizzano sono:
%//////////////////////// INIZIO TABELLA ////////////////////////
%//////////////////////// INIZIO TABELLA ////////////////////////
% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[!h]
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor[HTML]{C0C0C0}
{\color[HTML]{000000} \textbf{Metodo}}             & {\color[HTML]{000000} \textbf{Parametri}}                                                                               & {\color[HTML]{000000} \textbf{Descrizione}}                                                                          & {\color[HTML]{000000} \textbf{Azione}} \\ \hline
{\color[HTML]{000000} \textbf{ottieniListaPiatti}} & {\color[HTML]{000000} String idPersona}                                                                                 & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna la lista di \\ piatti di una persona\end{tabular}}          & {\color[HTML]{000000} GET}             \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{nuovoPiatto}}        & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}PiattoUpload piatto\\ String idPersona\end{tabular}}                   & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Aggiunge un nuovo\\ piatto\end{tabular}}                            & {\color[HTML]{000000} POST}            \\ \hline
{\color[HTML]{000000} \textbf{ottieniPiatto}}      & {\color[HTML]{000000} String idPiatto}                                                                                  & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Ritorna un piatto\\ per id\end{tabular}}                            & {\color[HTML]{000000} POST}            \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{eliminaPiatto}}      & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPersona\\ String idPiatto\end{tabular}}                       & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Elimina un piatto\\ per id\end{tabular}}                            & {\color[HTML]{000000} DELETE}          \\ \hline
{\color[HTML]{000000} \textbf{aggiornaPiatto}}     & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPiatto\\ String idPersona\\ PiattoUpload piatto\end{tabular}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Aggiorna un nuovo\\ piatto con i campi \\ specificati\end{tabular}} & {\color[HTML]{000000} PUT}             \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{ottieniListaMenu}}   & {\color[HTML]{000000} String idPersona}                                                                                 & {\color[HTML]{000000} Ritorna la lista dei menu}                                                                     & {\color[HTML]{000000} GET}             \\ \hline
{\color[HTML]{000000} \textbf{nuovoMenu}}          & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPersona\\ Menu menu\end{tabular}}                             & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Aggiunge un nuovo\\ menu\end{tabular}}                              & {\color[HTML]{000000} POST}            \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{ottieniMenu}}        & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPersona\\ String idMenu\end{tabular}}                         & {\color[HTML]{000000} Ritorna un menu per id}                                                                        & {\color[HTML]{000000} GET}             \\ \hline
{\color[HTML]{000000} \textbf{aggiornaMenu}}       & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPersona\\ String idMenu\\ Menu menu\end{tabular}}             & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Aggiorna un \\ determinato menu\end{tabular}}                       & {\color[HTML]{000000} PUT}             \\ \hline
\rowcolor[HTML]{EFEFEF}
{\color[HTML]{000000} \textbf{eliminaMenu}}        & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}String idPersona\\ String idMenu\end{tabular}}                         & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Elimina un \\ determinato menu\end{tabular}}                        & {\color[HTML]{000000} DELETE}          \\ \hline
\end{tabular}
\caption{Metodi del controller \textit{GestoreController}}
\end{table}
%//////////////////////// FINE TABELLA ////////////////////////
%//////////////////////// FINE TABELLA ////////////////////////
\newpage
\subsubsection{Panoramica del frontend}
\paragraph{Architettura}
L'applicativo è stato realizzato in Angular e dunque è composto da:
\begin{itemize}
  \item \textbf{Moduli}: utili per la separazione delle logiche; sono presenti diversi moduli come: il menu di navigazione, una sezione ordini, una per la guida, una per il gestore ed altri ancora;
  \item \textbf{Servizi}: sono presenti diversi servizi per la gestione della comunicazione con il backend, questo è lo strato in cui avverrà la migrazione;
  \item \textbf{Interceptor}: necessari per intercettare le chiamate HTTP e gestire il token di autenticazione;
  \item \textbf{Guardie}: permettono di bloccare l'accesso ad alcune funzionalità secondo diverse logiche, come ad esempio evitare di mostrare ad un utente che non è un gestore la pagina di gestione del menù;
  \item \textbf{Components}: previsti da Angular sono necessari per gestire le viste.
\end{itemize}
\subsubsection{Casi d'uso o Funzionalità}
Nella seguente sezione verranno illustrati brevemente i principali attori e i loro casi d'uso. Sono presenti due attori principali:
\begin{itemize}
  \item \textbf{Cliente}: si tratta del cliente del ristorante; a sua volta si suddivide in:
    \begin{itemize}
      \item \textit{Cliente non riconosciuto}: cliente non loggato; può effettuare tutte le azioni di consultazione del menu e dei piatti, ordinare i piatti, unirsi ad un tavolo, generare una sessione, ricercare i ristoranti e infine tutte le azioni riguardanti il login o registrazione;
      \item \textit{Cliente riconosciuto}: cliente loggato; estende il cliente non riconosciuto; potrà gestire i preferiti, comporre la propria blacklist, valutare i piatti o eseguire il logout;
    \end{itemize}
  \item \textbf{Gestore}: rappresenta il gestore di un ristorante; a sua volta si suddivide in:
    \begin{itemize}
      \item \textit{Gestore non riconosciuto}: gestore non loggato; può registrarsi o effettuare il login;
      \item \textit{Gestore riconosciuto}: gestore loggato con account da gestore; può effettuare il logout, visualizzare i clienti e i loro dati, attribuire punti o sottrarne ai clienti, confermare gli ordini, modificare e aggiungere piatti, menù e relative fasce orarie;
      \item \textit{Cameriere}: cameriere del ristorante; può visualizzare le ordinazioni di un determinato tavolo;
    \end{itemize}
\end{itemize}
\subsection{Migrazione del backend}
La migrazione del backend avviene secondo la tecnica \textit{Schema First}. È stata suddivisa in tre parti principali:
\begin{itemize}
  \item \textbf{Analisi sui tipi}: in questa prima fase si analizzano i tipi che devono essere esposti al client, dunque si procede con la scrittura del GraphQL Schema definendo i tipi;
  \item \textbf{Analisi sulle API}: sono state analizzate le API che si vuole migrare e successivamente sono state dichiarate nel GraphQL Schema;
  \item \textbf{Migrazione dei controller}: è stato adattato il codice del controller a GraphQL;
\end{itemize}
\subsubsection*{Analisi sui tipi e loro definizione}
É necessario analizzare e dunque riportare solo le entità che devono essere esposte al client. Oltre a queste è necessario definire nuovi tipi a seconda delle necessità. Di seguito vengono esposti i tipi che è stato scelto di dichiarare nel GraphQL Schema:
\begin{itemize}
  \item \textbf{Tipi di output}: sono i tipi che verranno ritornati al client, tra questi troviamo:
  \begin{itemize}
    \item \textit{Menu}: per ritornare il menu;
    \item \textit{FasciaOraria}: per ritornare le fasce orarie riguardo la disponibilità di un menù;
    \item \textit{Piatto}: per ritornare uno o più piatti; nella versione erano presenti due diverse rappresentazioni di piatto, qui ne sono stati uniti i campi sotto un unico tipo, così facendo backend e frontend potranno decidere quali campi sfruttare e quali no a seconda dell'utilizzo che deve essere fatto di questo oggetto;
    \item \textit{PiattoPreferito}: si differenzia dal tipo \textit{Piatto} in quanto deve specificare le preferenze dell'utente e le sue valutazioni riguardo ad uno specifico piatto;
    \item \textit{LoginSession}: per ritornare i dati di login, comprende una stringa per il token della sessione di login e la durata in secondi;
    \item \textit{Ordine}: si tratta di un oggetto che specifica un piatto, la quantità ordinata ed infine una eventuale nota;
    \item \textit{Utente}: per creare un nuovo utente o effettuare il login;
    \item \textit{Blacklist}: per ritornare la blacklist di un utente;
    \item \textit{Sessione}: per ritornare la sessione attiva in un determinato tavolo;
  \end{itemize}
  \item \textbf{Tipi di input}: sono i tipi che verranno forniti in input dal client, tra questi troviamo:
  \begin{itemize}
    \item \textit{PiattoInput}: per aggiunta e modifica di uno o più piatti che si ricevono in input dal client;
    \item \textit{MenuInput}: per aggiunta e modifica di uno o più menu;
    \item \textit{OrdineInput}: per aggiunta di un ordine, specifica il piatto, la sua quantità ed eventuali note da parte del cliente;
    \item \textit{UtenteInput}: per creare un nuovo utente o per effettuare il login;
  \end{itemize}
\end{itemize}
I tipi elencati sono esclusivamente quelli necessari per la definizione delle query, mutation e subscription. Verrà poi realizzato il tipo \textit{OperationSuccess} che viene ritornato, in caso di successo, per tutte quelle mutation che eseguono un'operazione e non ritornano dati. Questo tipo è composto da un solo campo String contenente un eventuale messaggio.\\ \\
A questo punto sono state create in Java le classi corrispondenti a tutti i tipi di input. Per i tipi di output questa operazione non è necessaria poiché i loro campi corrispondono alle entità in Java. Fanno eccezione i tipi \textit{Piatto}, \textit{PiattoPreferito} e \textit{LoginSession} poiché si differenziano leggermente dalle classi Java corrispondenti.
\subsubsection*{Analisi sulle API e loro definizione}
Questa fase prevede la dichiarazione delle query, mutation e subscription nel GraphQL Schema. Si tratta di una fase fondamentale in quanto permette di definire i tipi di input e di output di ciascuna operazione possibile. Rispetto alla progettazione iniziale si è deciso di aggiungere delle subscription. Di seguito è possibile visualizzare le query, le mutation e le subscription per ciascuno dei cinque controller presenti.\\
Le query rese disponibili sono:
\begin{lstlisting}[language=GraphQL, title={schema.graphqls}]
type Query {
  ##############UtenteController##############
  ottieniUtente(idPersona: String!): Utente
  ottieniBlacklist(idPersona: String!): blacklist
  ##############TavoloController##############
  ottieniSessione(idTavolo: String!): Sessione
  ottieniOrdiniPersona(idTavolo: String!, idPersona: String!): [Ordine]
  ottieniOrdiniTavolo(idTavolo: String!, idPersona: String!): [Ordine]
  ottieniGliOrdiniInArrivo(idTavolo: String!, idPersona: String!): [Ordine]
  ##############MenuController##############
  ottieniMenu(idMenu: String!, idPersona: String!): Menu
  ottieniListaFasce(idMenu: String!): [FasciaOraria]
  ottieniListaPreferiti(idMenu: String!, idPersona: String!): [Piatto]
  ##############GestoreController##############
  ottieniListaPiatti(idPersona: String!): [Piatto]
  ottieniListaMenu(idPersona: String!): [Menu]
  ottieniMenu(idPersona: String!, idMenu: String!): Menu
}
\end{lstlisting}
Le mutation realizzate sono:
\begin{lstlisting}[language=GraphQL, title={schema.graphqls}]
type Mutation {
  ##############LoginController##############
  eseguiLogin(utente: UtenteInput!): LoginSession
  ##############UtenteController##############
  registraUtente(utente: UtenteInput!): OperationSuccess
  modificaStatoPreferiti(idPersona: String!, idPiatto: String!, piatti: [PiattoInput!]!): OperationSuccess
  modificaValutazione(idPersona: String!, idPiatto: String!, piatti: PiattoPreferito!): OperationSuccess
  recuperoPassword(mail: String!): OperationSuccess
  verificaCodice(codice: String!): OperationSuccess
  reimpostaPassword(password: String!): OperationSuccess
  aggiornaBlackList(idPersona: String!, ingredienti: [String!]!): OperationSuccess
  ##############TavoloController##############
  creaSessione(idPersona: String!): Sessione
  chiudiSessione(idTavolo: String!): OperationSuccess
  modificaOrdiniPersona(idPersona: String!, idTavolo: String!, ordini: [OrdineInput!]!): OperationSuccess
  spostaGliOrdiniInArrivo(idTavolo: String!): OperationSuccess
  ##############GestoreController##############
  nuovoPiatto(idPersona: String!, piatto: PiattoInput!): Piatto
  eliminaPiatto(idPersona: String!, idPiatto: String!): OperationSuccess
  aggiornaPiatto(idPersona: String!, idPiatto: String!, piatto: PiattoInput!): OperationSuccess
  nuovoMenu(idPersona: String!, menu: MenuInput!): Menu
  aggiornaMenu(idPersona: String!, menu: MenuInput!): OperationSuccess
  eliminaMenu(idPersona: String!, idMenu: String!): OperationSuccess
}
\end{lstlisting}
Sono state introdotte infine le nuove subscription:
\begin{lstlisting}[language=GraphQL, title={schema.graphqls}]
type Subscription {
  ordiniTavoliRealTime(): [Ordine]
  visualizzaSezioniRealTime(): [Sessione]
}
\end{lstlisting}
Queste subscription permettono al client di ricevere in tempo reale i nuovi ordini effettuati in qualsiasi tavolo e quando vengono occupati nuovi tavoli.
\subsubsection*{Migrazione dei controller}
L'ultimo step per completare la migrazione del backend prevede la riscrittura dei controller. Per effettuare questo passaggio sono stati seguiti i seguenti punti:
\begin{itemize}
  \item \textbf{Cambio tipi}: sono stati cambiati i tipi negli argomenti, negli oggetti di ritorno e nell'implementazione dei vari resolver; questo perchè sono stati introdotti alcuni nuovi tipi ed è dunque necessario rispettare il mapping tra le dichiarazioni delle query, mutation e subscription nel GraphQL Schema e i corrispettivi resolver nei controller;
  \item \textbf{Cambio annotazioni}: sono state sostituite le annotazioni REST con quelle GraphQL;
  \item \textbf{Cambio struttura controller}: sono stati uniti i controller: \textit{LoginController}, \textit{UtenteController}, \textit{MenuController} e \textit{TavoloController} in un unico controller; questo perchè non è più necessario suddividere in endpoint multipli le richieste e perché tutti i controller elencati dichiaravano la stessa dipendenza dal servizio \textit{ClientService}.
  \item \textbf{Riscrittura del codice dei resolver}: sono stati riscritte le logiche dei vari resolver seguendo la struttura implementativa precedente; questo perché dopo aver apportato delle modifiche ai tipi in Java è stato necessario di conseguenza modificare alcune logiche;
  \item \textbf{Aggiunta subscription}: essendo state aggiunte due subscription si è reso necessario implementare i resolver corrispondenti.
\end{itemize}
\subsection{Migrazione del frontend da REST a GraphQL}
La migrazione del frontend è stata più semplice e ha seguito le seguenti fasi:
\begin{itemize}
  \item \textbf{Creazione interfacce dei tipi}: sono state create le interfacce per i nuovi tipi strutturati definiti durante la migrazione del backend;
  \item \textbf{Migrazione dei servizi}: è stata effettuata la riscrittura dei servizi in quanto responsabili delle chiamate al GraphQL Server e non più al REST Server;
  \item \textbf{Migrazione dell'interceptor}: l'interceptor è stato riscritto per l'intercettazione delle chiamate GraphQL e non più REST;
\end{itemize}
\subsubsection*{Interfacce dei tipi}
Le interfacce dei tipi sono necessarie per poter creare l'oggetto ricevuto dal backend nel'ambiente di frontend. Sono state dunque aggiunte le seguenti interfacce non presenti precedentemente:
\begin{itemize}
  \item \textit{LoginSession}: precedentemente venivano estrapolati i dati riguardanti l'idToken e la scadenza direttamente dal JSON, ora viene ritornato questo oggetto contenente i medesimi dati;
  \item \textit{OperationSuccess}: precedentemente il codice di stato della risposta HTTP era sufficiente per conoscerne l'esito; questo in GraphQL non accade, dunque viene ritornato appositamente questo oggetto;
  \item \textit{Sessione}: precedentemente veniva direttamente estrapolato dal JSON l'id della sessione, ora viene ritornato questo oggetto dal backend;
\end{itemize}
\subsubsection{Migrazione dei servizi}
I servizi si occupano della comunicazione con il backend per questo motivo sono stati riscritti utilizzando al posto dell'oggetto \textit{HttpClient} per costruire chiamate REST, l'oggetto \textit{Apollo} per costruire quelle GraphQL.
I servizi che sono stati migrati sono:
\begin{itemize}
  \item \textbf{MenuService}: utilizzato per la gestione dei menu;
  \item \textbf{ordiniService}: utilizzato per la gestione degli ordini;
  \item \textbf{authService}: utilizzato per la gestione e verifica dei login;
  \item \textbf{tavoloService}: utilizzato per la gestione delle sessioni nei tavoli;
\end{itemize}
Gli altri servizi presenti non sono stati modificati in quanto non gestivano alcun tipo di comunicazione con il backend.
\subsubsection*{Migrazione dell'interceptor}
L'interceptor di Angular viene creato attraverso l'implementazione dell'interfaccia \textit{HttpInterceptor} ed è stato utilizzato nel frontend dell'applicativo per l'aggiunta nell'header della chiamata del token di identificazione. Il token di identificazione viene ritornato al client dopo il login di un utente e sarà necessario in seguito per identificare le azioni dell'utente loggato.\\ \\
É necessario dunque apportare una modifica all'interceptor realizzato precedentemente poiché non sono più presenti endpoints multipli, ma dopo la migrazione in GraphQL è sufficiente controllare e dunque intercettare le chiamate indirizzate ad un singolo endpoint.
